\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{acronym}
\usepackage{todonotes}
\acrodef{ISL}{Integer Set Library}

\title{Seeds for a Schedule Tree} % Thcs Sven
\author{Serge Guelton, Sven Verdoolaeg, Albert Cohen}

\begin{document}

\maketitle

\section*{Motivations}

This document formalizes the design and some use cases of \emph{schedule
trees}, a refinement to the concept of \emph{schedule} used in the \ac{ISL}.
Informally, a schedule tree is an ordered tree where nodes are union sets, with
a $\mathrm{flat}$ operator to turn a schedule tree into a schedule.

The benefits of using a tree representation over a flat representation for a
schedule is that it naturally fits the hierarchical structure of some piece of
codes. Moreover there is no loss of expressiveness as any schedule can fit into
a tree as a tree with a single node.

Typical cases where a tree structure are useful are:

\begin{itemize}

    \item Transformation of only a part of the schedule, say the last
        dimensions, while leaving the first dimensions untouched. At the loop
        level, it means one can modify inner loops without the burden of
        specifying outer loops. More generally, one can specify a set of high
        level schedule transformations that work indifferently on any sub tree,
        as long as some constraints are respected. Proposals for such
        transformations are listed in
        Section~\ref{sec:schedule-tree-transformations}.

    \item Usage of different scheduling strategies and code generator for different
        part of the tree. This is a common situation in heterogeneous computing
        where different parts of a schedule will be mapped on different hardware.

    \item Generation of schedule in an inter-procedural context. Languages such
        as \textsc{Pencil} make it possible to annotate a function with
        summarized access informations that can be used to generate a
        hierarchical schedule where some leaves are generated from the
        annotation, and their parents from code analysis. It is also possible
        to make sure some dimensions are never modified by leaving them in a
        special immutable node. This node can for instance represent the
        schedule of a function call from a third-party function.

\end{itemize}

\section*{Notations}

Tuples are denoted between angle brackets, as in $\langle a_0, \ldots,
a_{n-1}\rangle$.

The Cartesian product of set $\mathcal{S}$ with itself $n$ times is denoted
$\mathcal{S}^n$.

\section{Formal Definition}


Let $\mathcal{U}$ be the domain of all union maps and $\mathcal{T}$ the domain
of all schedule trees, defined as:

\[
    \begin{array}{lcl}
        \mathcal{T}_k &=& \{ \langle u, v\rangle \mid u \in \mathcal{U}, \exists k\in\mathbb{N}, v \in \mathcal{T}^k \} \\
        \mathcal{T} &=& \displaystyle\bigcup_{k\in\mathbb{N}} \mathcal{T}_k\\
    \end{array}
\]

\noindent \emph{i.e.}\ a schedule tree holds a union map and any number of children that also are schedule trees.

The function that yields the relation $u$ of a tree is called $\mathrm{rel}:\mathcal{T} \rightarrow \mathcal{U}$.

The function that yields the children $v$ of a tree is called $\mathrm{chd}:\mathcal{T} \rightarrow \displaystyle\prod_{k\in\mathbb{N}}\mathcal{T}^k$.

\subsection{Tree to Union Maps}

Given any schedule tree, we define a flattening operation $\mathrm{flat}$

\[
    \mathrm{flat}: \mathcal{T} \rightarrow \mathcal{U}
\]

\noindent such that

\[
    \begin{array}{lcl}
        \mathrm{flat}(\langle u, \langle\rangle \rangle) &=& u \\
        \mathrm{flat}(\langle u, \langle v_0, \ldots, v_k\rangle \rangle) &=& \mathrm{range\_product}(u, \bigcup_{k=0}^{k=n} \mathrm{flat}(\mathrm{append\_dim}(k, v_k)) \\
    \end{array}
\]

\noindent where $\mathrm{range\_product}$ performs a flat range product between to elements of $\mathcal{U}$ and $\mathrm{append\_dim}$ appends a constant dimension to the out space of a schedule:

\[
    \mathrm{range\_product}(A \cap B, C \rightarrow D) \rightarrow (A \times C) \rightarrow (B, D)
\]

\noindent and

\[
    \mathrm{append\_dim}(k, \langle A \rightarrow B, v\rangle) \rightarrow \langle A \rightarrow (\{k\} \times B), v \rangle
\]

\subsubsection*{Example}

For instance, let $t$ be a simple tree:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i,j] \rightarrow [i] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i,j] \rightarrow [j] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i,j] \rightarrow [j] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]

Flattening $t$ turns it into a regular union map, where the ordering of the children of the root tree is made explicit:

\[
    \mathrm{flat}(t) = \{ [i,j] \rightarrow [i,0,j] ; [i,j] \rightarrow [i,1,j] \}
\]

\subsection{Union Maps to Tree}

{ \raggedleft\emph{I'd like to define a function that turns a union map into a
tree, automatically spawning children when all the value of a dimension are
integer singletons. This is directly related to the definition of a canonical tree\dots} }

\[
    \mathrm{split}: \mathcal{U} \rightarrow \mathcal{T}
\]



\section{Schedule Trees Transformations}
\label{sec:schedule-tree-transformation}

The primary interest of a tree representation for schedules is that a part of
the schedule can be updated while leaving the other parts untouched. For instance, consider the following schedule:

\[
    s = \{ S_0[i,j,k,l] \rightarrow [i,j,0,k,l] ; S_1[i,j,k] \rightarrow [i,j,1,k] \}
\]

If we want to permute the first two output dimensions $i, j$ for the maps
$S_0, S_1$, we do not care much about the remaining dimensions. Yet we have to
specify them in the schedule transformation:

\[
    p = \{ S_0[i,j,o_0,o_1,o_2] \rightarrow [j,i,o_0,o_1,o_2] ; S_1[i,j,o_0, o_1] \rightarrow [j,i,o_0,o_1] \}
\]

\noindent which is particularly tedious. Using a tree representation $t_s$ for $s$, one could get:

\[
    \begin{array}{lcll}
        t_s &=& \{ &\\
            & &    & \{S_0[i,j,k,l] \rightarrow [i,j] ; \{S_1[i,j,k] \rightarrow [i,j] \},\\
            & &    & \quad\{ \{ S_0[i,j,k,l] \rightarrow [0,k,l] \} \}\\
            & &    & \quad\{ \{ S_1[i,j,k] \rightarrow [i,j,1,k] \} \}\\
            & & \} &\\
    \end{array}
\]

\noindent and use a more compact way to specify the transformation of the root of the tree:

\[
    T_p = \{ S_0[i,j,k,l] \rightarrow [j,i] ; S_1[i,j,k] \rightarrow [j,i] \}
\]

However the signature of a tree transformation is slightly different:

\[
    T_\mathrm{apply}: \mathcal{T}_i \rightarrow ( \mathcal{T}_i \rightarrow \mathcal{T}_j) \rightarrow \mathcal{T}_j
\]


\noindent so the tree transformation that permutes the two first dimensions of the tree can be written:

\[
    T'_p(\langle u, v \rangle) = \langle T_p(u), v \rangle
\]


The following sections defines a few common schedule transformation in terms of schedule tree transformation.

\subsection{Interchange}

\emph{Loop interchange} is the process of interchanging several loop iteration
variable. In terms of schedule, it boils down to a permutation of the time
domain.

\[
    \mathrm{interchange}: \mathcal{T}_k \rightarrow P \rightarrow \mathcal{T}_k
\]

\noindent where $P$ is the set of domain permutations. Its behavior is described as:

\[
    \mathrm{interchange}(\langle u, v\rangle, p) = \langle p(u), v\rangle)
\]

\noindent \emph{i.e.}\ it leaves the children of the tree untouched and
permutes the output dimension of $u$ according to $p$.

\subsubsection*{Example}

Let's interchange a schedule tree $t$ through the application of permutation $p$:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i,j,k] \rightarrow [i,j,k] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i,j,k] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i,j,k] \rightarrow [] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
        p &=& (x, y, z) \mapsto (y, z, x) \\
        t'&=& \mathrm{interchange}(t, p) \\
    \end{array}
\]

\noindent in the end, the value of $t'$ is:

\[
    \begin{array}{lcl}
        t'&=& \langle \\
          & & \quad\{[i,j,k] \rightarrow [k,j,i] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i,j,k] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i,j,k] \rightarrow [] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]


\subsection{Index Set Split}

\emph{Index set splitting} is the process of splitting the index set of a loop
into parts. In terms of schedule, it can be expressed as the duplication of a
schedule with an additional time constraint.

\[
    \mathrm{index\_set\_split}: \mathcal{T}_k \rightarrow \mathcal{U} \rightarrow \mathcal{T}_2
\]

Its behavior is described as:

\[
    \mathrm{index\_set\_split}(\langle u, v\rangle, m) = \langle  \{\}, \langle  \langle  m(u), v\rangle, \langle  u - m(u), v\rangle \rangle \rangle
\]

\noindent \emph{i.e.}\ $m$ is used to select part of the time domain that will
be used for the first child, the complement is used for the second child.

\subsubsection*{Example}

Let's split a schedule tree $t$ according to the union map $m$:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i] \rightarrow [i] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
        m &=& \{ [x] \rightarrow [x] \mid x < 3 \} \\
        t'&=& \mathrm{index\_set\_split}(t, m) \\
    \end{array}
\]

\noindent in the end, the value of $t'$ is:

\[
    \begin{array}{lcl}
        t'&=& \langle \\
          & & \quad\{[i] \rightarrow [i] \mid i < 3 \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle, \\
          & & \quad\{[i] \rightarrow [i] \mid i >= 3 \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \rangle \\
    \end{array}
\]

\subsection{Tile}

\emph{Loop tiling} is the process of changing the iteration order of a loop
nest into tiles in order to improve locality. In terms of schedule, tiling
generally adds new iteration domains with additional blocking constraints. This
section is limited to rectangular tiling.

\[
    \mathrm{tile}: \mathcal{T}_k \rightarrow \mathbb{N}^k \rightarrow \mathcal{T}_1
\]

Its behavior is described as:

\[
    \mathrm{tile}(\langle u, v\rangle, t) = \langle  s_\mathrm{outer}(t)(u), \langle  u, v \rangle \rangle
\]

\noindent where

\[
    \begin{array}{l}
        s_\mathrm{outer} \rightarrow \mathcal{U} \rightarrow \mathbb{N}^k \rightarrow \mathcal{U} \\
    s_\mathrm{outer}(u, t) = \{ [v_0, \ldots, v_k] -\rangle [w_0, \ldots, w_k] \mid \bigwedge_{i=0}^k(\mathrm{mod}(w_0, t_0) = 0 \wedge w_0 \le v_0 < w_0 + t_0) \}
    \end{array}
\]

\subsubsection*{Example}

Let's tile a schedule tree $t$ according to the tiles $v$:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i,j] \rightarrow [i,j] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i,j] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i,j] \rightarrow [i+j] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
        v &=& \langle 4, 8 \rangle\\
        t'&=& \mathrm{tile}(t, v) \\
    \end{array}
\]

\noindent in the end, the value of $t'$ is:

\[
    \begin{array}{lcl}
        t'&=& \langle \\
          & & \quad\{[i,j] \rightarrow [i_t,j_t] \mid \mathrm{mod}(i_t, 4) = 0 \wedge i_t \le i < i_t + 4 \wedge \mathrm{mod}(j_t, 8) = 0 \wedge j_t \le i < j_t + 8\},\\
          & & \quad\langle \\
          & & \quad\quad\{ [i,j] \rightarrow [i,j] \},\\
          & & \quad\quad\langle \\
          & & \quad\quad\quad \langle\{ [i,j] \rightarrow [] \}, \langle\rangle\rangle,\\
          & & \quad\quad\quad  \langle\{ [i,j] \rightarrow [i+j] \}, \langle\rangle\rangle\\
          & & \quad\quad\rangle \\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]

\subsection{Fuse}

\emph{Loop fusion} is the process of fusing several loops in one. In terms of
schedule, a simple version of loop fusion can be expressed as a swap between a
constant dimension and a varying dimension.

\[
    \mathrm{fuse}:  \mathcal{T}_k \rightarrow  \mathbb{N}^j \rightarrow \mathbb{N} \rightarrow  \mathcal{T}_{k - j + 1}
\]

Its behavior is described as: 

\[
    \mathrm{fuse}(\langle u, \langle v_0, \ldots, v_k\rangle \rangle, \langle f_0, \ldots, f_j\rangle, t) = \langle  u, F \rangle
\]

\noindent where:

\[
    F = \left\langle 
    \begin{array}{ccl}
         \langle \mathrm{rel}(f_0) \cup \ldots \cup \mathrm{rel}(f_j), \langle \mathrm{chd}(f_0), \ldots, \mathrm{chd}(f_j)\rangle  \rangle & \mid& i = t \\
         v_i & \mid& i \neq t \wedge  v_i \not\in \{f_0, \ldots, f_j\} \\
    \end{array}
    \right\rangle
\]

\subsubsection*{Example}

Let's fuse the first and third children of a schedule tree $t$ into the third child, leaving the second untouched:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{A[i] \rightarrow []; B[i] \rightarrow []; C[i] \rightarrow []  \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ A[i] \rightarrow [i] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ B[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\quad \langle\{ C[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
        t'&=& \mathrm{fuse}(t, t[0], t[2], 2) \\
    \end{array}
\]

\noindent in the end, the value of $t'$ is:

\[
    \begin{array}{lcl}
        t'&=& \langle \\
          & & \quad\{[i] \rightarrow [] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ B[i] \rightarrow [i] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ A[i] \rightarrow [i]; C[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]


\subsection{Distribute}

\emph{Loop distribution} is the process of distributing the body of a loop
across several iterations. It's the opposite transformation of \emph{loop
fusion}. In terms of schedule, a simple version of loop distribution can be
expressed as a swap between a constant dimension and a varying dimension.

\[
    \mathrm{distribute}: \mathcal{T}_k \rightarrow \mathbb{N}^j \rightarrow \mathcal{T}_{j+1}
\]

Its behavior is described as:

\[
    \mathrm{distribute}(\langle  u, \langle v_0, \ldots, v_k\rangle \rangle, \langle d_0, \ldots, d_j\rangle) = \langle u \cap \mathbb{Z}^{|u|_\mathrm{out}-1}, D\rangle
\]

\noindent where:

\[
    D = \left\langle 
    \begin{array}{ccl}
        \langle  u_{-1}, v_i \rangle & \mid & i \in \{ d_0, \ldots, d_j\} \\
        \langle  u_{-1}, \langle  v_j \mid j \not\in \{ d_0, \ldots, d_j\}\rangle \rangle  & & 
    \end{array}
    \right\rangle
\]

\subsubsection*{Example}

Let's distribute the second child of schedule tree $t$:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i] \rightarrow [] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ B[i] \rightarrow [i] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ A[i] \rightarrow [i]; C[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
        t'&=& \mathrm{distribute}(t, 1) \\
    \end{array}
\]

\noindent in the end, the value of $t'$ is:

\[
    \begin{array}{lcl}
        t'&=& \langle \\
          & & \quad\{[i] \rightarrow [] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ B[i] \rightarrow [i] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ A[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\quad \langle\{ C[i] \rightarrow [i] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]
\todo{how is the order chosen?}

\end{document}
