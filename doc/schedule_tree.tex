\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{acronym}
\acrodef{ISL}{Integer Set Library}

\title{Seeds for a Schedule Tree} % Thcs Sven
\author{Serge Guelton, Sven Verdoolaeg, Albert Cohen}

\begin{document}

\maketitle

\section*{Motivations}

This document formalizes the design and some use cases of \emph{schedule
trees}, a refinement to the concept of \emph{schedule} used in the \ac{ISL}. The
benefits of using a tree representation over a flat representation for a
schedule is that it makes it easier to manipulate part of a schedule, for
instance to transform only the inner domain of a schedule while leaving the
outer domain untouched.

In the scope of heterogeneous computing, a tree representation also makes sense
as part of the schedule maps to computations done on a given processor while
other parts map to computations done on another piece of hardware. Specific
transformations can be applied on a sub tree depending on the target
accelerator it will ultimately map to. Likewise a specific code generator can
be used to process a sub tree.

When analysing code that uses third-party libraries, it may be difficult to
compute the original schedule of a piece of code as it requires some kind of
inter procedural analysis. Using a tree representation, one can easily combine
the pre-computed schedule of library functions with the schedule of the call
site.

\section*{Notations}

Tuples are denoted between angle brackets, as in $\langle a_0, \ldots, a_{n-1}\rangle$.

\section{Formal Definition}


Let $\mathcal{U}$ be the domain of all union maps and $\mathcal{T}$ the domain
of all schedule trees, defined as:

\[
    \begin{array}{lcl}
        \mathcal{T}_k &=& \{ \langle u, v\rangle \mid u \in \mathcal{U}, \exists k\in\mathbb{N}, v \in \mathcal{T}^k \} \\
        \mathcal{T} &=& \displaystyle\bigcup_{k\in\mathbb{N}} \mathcal{T}_k\\
    \end{array}
\]

\noindent \emph{i.e.}\ a schedule tree holds a union map and any number of children that also are schedule trees.

The function that yields the relation $u$ of a tree is called $\mathrm{rel}:\mathcal{T} \rightarrow \mathcal{U}$.

The function that yields the children $v$ of a tree is called $\mathrm{chd}:\mathcal{T} \rightarrow \displaystyle\prod_{k\in\mathbb{N}}\mathcal{T}^k$.

\subsection{Tree to Union Maps}

Given any schedule tree, we define a flattening operation $\mathrm{flat}$

\[
    \mathrm{flat}: \mathcal{T} \rightarrow \mathcal{U}
\]

\noindent such that

\[
    \begin{array}{lcl}
        \mathrm{flat}(\langle u, \langle\rangle \rangle) &=& u \\
        \mathrm{flat}(\langle u, \langle v_0, \ldots, v_k\rangle \rangle) &=& \mathrm{range\_product}(u, U_{k=0}^{k=n} \mathrm{flat}(\mathrm{append\_dim}(k, v_k)) \\
    \end{array}
\]

\noindent where $\mathrm{range\_product}$ performs a flat range product between to elements of $\mathcal{U}$ and $\mathrm{append\_dim}$ appends a constant dimension to the out space of a schedule:

\[
    \mathrm{range\_product}(A \rightarrow B, C \rightarrow D) \rightarrow (A \times C) \rightarrow (B, D)
\]

\noindent and

\[
    \mathrm{append\_dim}(k, \langle A \rightarrow B, v\rangle) \rightarrow \langle A \rightarrow (\{k\} \times B), v \rangle
\]

\subsubsection*{Example}

For instance, let $t$ be a simple tree:

\[
    \begin{array}{lcl}
        t &=& \langle \\
          & & \quad\{[i,j] \rightarrow [i] \},\\
          & & \quad\langle \\
          & & \quad\quad \langle\{ [i,j] \rightarrow [j] \}, \langle\rangle\rangle,\\
          & & \quad\quad \langle\{ [i,j] \rightarrow [j] \}, \langle\rangle\rangle\\
          & & \quad\rangle \\
          & & \rangle \\
    \end{array}
\]

Flattening $t$ turns it into a regular union map, where the ordering of the children of the root tree is made explicit:

\[
    \mathrm{flat}(t) = \{ [i,j] \rightarrow [i,0,j] ; [i,j] \rightarrow [i,1,j] \}
\]

\subsection{Union Maps to Tree}

{ \raggedleft\emph{I'd like to define a function that turns a union map into a
tree, automatically spawning children when all the value of a dimension are
integer singletons. This is directly related to the definition of a canonical tree\dots} }

\[
    \mathrm{split}: \mathcal{U} \rightarrow \mathcal{T}
\]



\section{Schedule Trees Transformations}

The primary interest of a tree representation for schedules is that a part of
the schedule can be updated while leaving the other parts untouched. For instance, consider the following schedule:

\[
    s = \{ S_0[i,j,k,l] \rightarrow [i,j,0,k,l] ; S_1[i,j,k] \rightarrow [i,j,1,k] \}
\]

If we want to permute the first two output dimensions $i, j$ for the maps
$S_0, S_1$, we do not care much about the remaining dimensions. Yet we have to
specify them in the schedule transformation:

\[
    p = \{ S_0[i,j,o_0,o_1,o_2] \rightarrow [j,i,o_0,o_1,o_2] ; S_1[i,j,o_0, o_1] \rightarrow [j,i,o_0,o_1] \}
\]

\noindent which is particularly tedious. Using a tree reprensentation $t_s$ for $s$, one could get:

\[
    \begin{array}{lcll}
        t_s &=& \{ &\\
            & &    & \{S_0[i,j,k,l] \rightarrow [i,j] ; \{S_1[i,j,k,l] \rightarrow [i,j] \},\\
            & &    & \quad\{ \{ S_0[i,j,k,l] \rightarrow [0,k,l] \} \}\\
            & &    & \quad\{ \{ S_1[i,j,k] \rightarrow [i,j,1,k] \} \}\\
            & & \} &\\
    \end{array}
\]

\noindent and use a more compact way to specify the transformation of the root of the tree:

\[
    T_p = \{ S_0[i,j] \rightarrow [j,i] ; S_1[i,j] \rightarrow [j,i] \}
\]

However the signature of a tree transformation is slightly different:

\[
    T_\mathrm{apply}: \mathcal{T}_i \rightarrow ( \mathcal{T}_i \rightarrow \mathcal{T}_j) \rightarrow \mathcal{T}_j
\]


\noindent so the tree transformation that permutes the two first dimensions of the tree can be written:

\[
    T'_p(\langle u, v \rangle) = \langle T_p(u), v \rangle
\]


The following sections defines a few common schedule transformation in terms of schedule tree transformation.

\subsection{Interchange}

\emph{Loop interchange} is the process of interchanging several loop iteration
variable. In terms of schedule, it boils down to a permutation of the time
domain.

\[
    \mathrm{interchange}: \mathcal{T}_k \rightarrow P \rightarrow \mathcal{T}_k
\]

\noindent where $P$ is the set of domain permutations. Its behavior is described as:

\[
    \mathrm{interchange}(\langle u, v\rangle, p) = \langle p(u), v\rangle)
\]

\noindent \emph{i.e.}\ it leaves the children of the tree untouched and
permutes the output dimension of $u$ according to $p$.

\subsection{Index Set Split}

\emph{Index set splitting} is the process of splitting the index set of a loop
into parts. In terms of schedule, it can be expressed as the duplication of a
schedule with an additional time constraint.

\[
    \mathrm{index\_set\_split}: \mathcal{T}_k \rightarrow U \rightarrow \mathcal{T}_2
\]

Its behavior is described as:

\[
    \mathrm{index\_set\_split}(\langle u, v\rangle, m) = \langle  {}, \langle  \langle  m(u), v\rangle, \langle  u - m(u), v\rangle \rangle \rangle
\]

\noindent \emph{i.e.}\ $m$ is used to select part of the time domain that will
be used for the first child, the complement is used for the second child.

\subsection{Tile}

\emph{Loop tiling} is the process of changing the iteration order of a loop
nest into tiles in order to improve locality. In terms of schedule, tiling
generally adds new iteration domains with additional blocking constraints. This
section is limited to rectangular tiling.

\[
    \mathrm{tile}: \mathcal{T}_k \rightarrow \mathbb{N}^k \rightarrow \mathcal{T}_1
\]

Its behavior is described as:

\[
    \mathrm{tile}(\langle u, v\rangle, t) = \langle  s_\mathrm{outer}(t)(u), \langle  u, v \rangle \rangle
\]

\noindent where

\[
    \begin{array}{l}
        s_\mathrm{outer} \rightarrow \mathcal{U} \rightarrow \mathbb{N}^k \rightarrow \mathcal{U} \\
    s_\mathrm{outer}(u, t) = \{ [v_0, \ldots, v_k] -\rangle [w_0, \ldots, w_k] \mid \bigwedge_{i=0}^k(mod(w_0, t_0) = 0 \wedge w_0 \le v_0 < w_0 + t_0) \}
    \end{array}
\]

\subsection{Fuse}

\emph{Loop fusion} is the process of fusing several loops in one. In terms of
schedule, a simple version of loop fusion can be expressed as a swap between a
constant dimension and a varying dimension.

\[
    \mathrm{fuse}:  \mathcal{T}_k \rightarrow  \mathbb{N}^j \rightarrow \mathbb{N} \rightarrow  \mathcal{T}_{k - j + 1}
\]

Its behavior is described as: 

\[
    \mathrm{fuse}(\langle u, \langle v_0, \ldots, v_k\rangle \rangle, \langle f_0, \ldots, f_j\rangle, t) = \langle  u, F \rangle
\]

\noindent where:

\[
    F = \left\langle 
    \begin{array}{ccl}
         \langle \mathrm{rel}(f_0) \cup \ldots \cup \mathrm{rel}(f_j), \langle \mathrm{chd}(f_0), \ldots, \mathrm{chd}(f_j)\rangle  \rangle & \mid& i = t \\
         v_i & \mid& i \neq t \wedge  v_i \not\in \{f_0, \ldots, f_j\} \\
    \end{array}
    \right\rangle
\]

\subsection{Distribute}

\emph{Loop distribution} is the process of distributing the body of a loop
across several iterations. It's the opposite transformation of \emph{loop
fusion}. In terms of schedule, a simple version of loop distribution can be
expressed as a swap between a constant dimension and a varying dimension.

\[
    \mathrm{distribute}: \mathcal{T}_k \rightarrow \mathbb{N}^j \rightarrow \mathcal{T}_{j+1}
\]

Its behavior is described as:

\[
    \mathrm{distribute}(\langle  u, \langle v_0, \ldots, v_k\rangle \rangle, \langle d_0, \ldots, d_j\rangle) = \langle u \cap \mathbb{Z}^{|u|_\mathrm{out}-1}, D\rangle
\]

\noindent where:

\[
    D = \left\langle 
    \begin{array}{ccl}
        \langle  u_{-1}, v_i \rangle & \mid & i \in \{ d_0, \ldots, d_j\} \\
        \langle  u_{-1}, \langle  v_j \mid j \not\in \{ d_0, \ldots, d_j\}\rangle \rangle  & & 
    \end{array}
    \right\rangle
\]

\end{document}
